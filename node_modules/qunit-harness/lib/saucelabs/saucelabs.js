'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator').default;

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default').default;

exports.__esModule = true;
exports.openTunnel = openTunnel;
exports.closeTunnel = closeTunnel;
exports.run = run;

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _belymA2105SauceTunnel = require('@belym.a.2105/sauce-tunnel');

var _belymA2105SauceTunnel2 = _interopRequireDefault(_belymA2105SauceTunnel);

var _runner = require('./runner');

var _runner2 = _interopRequireDefault(_runner);

var _utilsWait = require('../utils/wait');

var _utilsWait2 = _interopRequireDefault(_utilsWait);

var CREATE_TUNNEL_TIMEOUT = 30 * 1000;
var MAX_CREATE_TUNNEL_ATTEMPT_COUNT = 20;

function openTunnel(settings) {
    var open, tunnel, counter;
    return _regeneratorRuntime.async(function openTunnel$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                open = function open() {
                    return new _pinkie2.default(function (resolve, reject) {
                        var tunnelId = Math.floor(new Date().getTime() / 1000 - 1230768000).toString();
                        var tunnel = new _belymA2105SauceTunnel2.default(settings.username, settings.accessKey, tunnelId, true);

                        tunnel.start(function (isCreated) {
                            if (!isCreated) resolve(null);else {
                                settings.tunnelIdentifier = tunnelId;
                                resolve(tunnel);
                            }
                        });
                    });
                };

                tunnel = null;
                counter = 0;

            case 3:
                if (!(!tunnel && counter++ < MAX_CREATE_TUNNEL_ATTEMPT_COUNT)) {
                    context$1$0.next = 16;
                    break;
                }

                context$1$0.next = 6;
                return _regeneratorRuntime.awrap(open());

            case 6:
                tunnel = context$1$0.sent;

                if (tunnel) {
                    context$1$0.next = 13;
                    break;
                }

                context$1$0.next = 10;
                return _regeneratorRuntime.awrap(_utilsWait2.default(CREATE_TUNNEL_TIMEOUT));

            case 10:
                console.log('Failed to create Sauce tunnel (attempt ' + counter + ' from ' + MAX_CREATE_TUNNEL_ATTEMPT_COUNT + ')');
                context$1$0.next = 14;
                break;

            case 13:
                console.log('Sauce tunnel created');

            case 14:
                context$1$0.next = 3;
                break;

            case 16:
                if (tunnel) {
                    context$1$0.next = 20;
                    break;
                }

                throw 'Failed to create Sauce tunnel';

            case 20:
                return context$1$0.abrupt('return', tunnel);

            case 21:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function closeTunnel(tunnel) {
    return new _pinkie2.default(function (resolve, reject) {
        if (!tunnel) reject();else tunnel.stop(resolve);
    });
}

function run(settings) {
    var runner;
    return _regeneratorRuntime.async(function run$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                runner = new _runner2.default(settings);
                context$1$0.next = 3;
                return _regeneratorRuntime.awrap(runner.runTests());

            case 3:
                return context$1$0.abrupt('return', context$1$0.sent);

            case 4:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}