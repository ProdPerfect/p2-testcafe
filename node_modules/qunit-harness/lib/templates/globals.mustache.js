// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"pinkie": {
		"index.js": function (exports, module, require) {
			'use strict';

			var PENDING = 'pending';
			var SETTLED = 'settled';
			var FULFILLED = 'fulfilled';
			var REJECTED = 'rejected';
			var NOOP = function () {};
			var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

			var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
			var asyncQueue = [];
			var asyncTimer;

			function asyncFlush() {
				// run promise callbacks
				for (var i = 0; i < asyncQueue.length; i++) {
					asyncQueue[i][0](asyncQueue[i][1]);
				}

				// reset async asyncQueue
				asyncQueue = [];
				asyncTimer = false;
			}

			function asyncCall(callback, arg) {
				asyncQueue.push([callback, arg]);

				if (!asyncTimer) {
					asyncTimer = true;
					asyncSetTimer(asyncFlush, 0);
				}
			}

			function invokeResolver(resolver, promise) {
				function resolvePromise(value) {
					resolve(promise, value);
				}

				function rejectPromise(reason) {
					reject(promise, reason);
				}

				try {
					resolver(resolvePromise, rejectPromise);
				} catch (e) {
					rejectPromise(e);
				}
			}

			function invokeCallback(subscriber) {
				var owner = subscriber.owner;
				var settled = owner._state;
				var value = owner._data;
				var callback = subscriber[settled];
				var promise = subscriber.then;

				if (typeof callback === 'function') {
					settled = FULFILLED;
					try {
						value = callback(value);
					} catch (e) {
						reject(promise, e);
					}
				}

				if (!handleThenable(promise, value)) {
					if (settled === FULFILLED) {
						resolve(promise, value);
					}

					if (settled === REJECTED) {
						reject(promise, value);
					}
				}
			}

			function handleThenable(promise, value) {
				var resolved;

				try {
					if (promise === value) {
						throw new TypeError('A promises callback cannot return that same promise.');
					}

					if (value && (typeof value === 'function' || typeof value === 'object')) {
						// then should be retrieved only once
						var then = value.then;

						if (typeof then === 'function') {
							then.call(value, function (val) {
								if (!resolved) {
									resolved = true;

									if (value === val) {
										fulfill(promise, val);
									} else {
										resolve(promise, val);
									}
								}
							}, function (reason) {
								if (!resolved) {
									resolved = true;

									reject(promise, reason);
								}
							});

							return true;
						}
					}
				} catch (e) {
					if (!resolved) {
						reject(promise, e);
					}

					return true;
				}

				return false;
			}

			function resolve(promise, value) {
				if (promise === value || !handleThenable(promise, value)) {
					fulfill(promise, value);
				}
			}

			function fulfill(promise, value) {
				if (promise._state === PENDING) {
					promise._state = SETTLED;
					promise._data = value;

					asyncCall(publishFulfillment, promise);
				}
			}

			function reject(promise, reason) {
				if (promise._state === PENDING) {
					promise._state = SETTLED;
					promise._data = reason;

					asyncCall(publishRejection, promise);
				}
			}

			function publish(promise) {
				promise._then = promise._then.forEach(invokeCallback);
			}

			function publishFulfillment(promise) {
				promise._state = FULFILLED;
				publish(promise);
			}

			function publishRejection(promise) {
				promise._state = REJECTED;
				publish(promise);
				if (!promise._handled && isNode) {
					global.process.emit('unhandledRejection', promise._data, promise);
				}
			}

			function notifyRejectionHandled(promise) {
				global.process.emit('rejectionHandled', promise);
			}

			/**
			 * @class
			 */
			function Promise(resolver) {
				if (typeof resolver !== 'function') {
					throw new TypeError('Promise resolver ' + resolver + ' is not a function');
				}

				if (this instanceof Promise === false) {
					throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
				}

				this._then = [];

				invokeResolver(resolver, this);
			}

			Promise.prototype = {
				constructor: Promise,

				_state: PENDING,
				_then: null,
				_data: undefined,
				_handled: false,

				then: function (onFulfillment, onRejection) {
					var subscriber = {
						owner: this,
						then: new this.constructor(NOOP),
						fulfilled: onFulfillment,
						rejected: onRejection
					};

					if ((onRejection || onFulfillment) && !this._handled) {
						this._handled = true;
						if (this._state === REJECTED && isNode) {
							asyncCall(notifyRejectionHandled, this);
						}
					}

					if (this._state === FULFILLED || this._state === REJECTED) {
						// already resolved, call callback async
						asyncCall(invokeCallback, subscriber);
					} else {
						// subscribe
						this._then.push(subscriber);
					}

					return subscriber.then;
				},

				catch: function (onRejection) {
					return this.then(null, onRejection);
				}
			};

			Promise.all = function (promises) {
				if (!Array.isArray(promises)) {
					throw new TypeError('You must pass an array to Promise.all().');
				}

				return new Promise(function (resolve, reject) {
					var results = [];
					var remaining = 0;

					function resolver(index) {
						remaining++;
						return function (value) {
							results[index] = value;
							if (!--remaining) {
								resolve(results);
							}
						};
					}

					for (var i = 0, promise; i < promises.length; i++) {
						promise = promises[i];

						if (promise && typeof promise.then === 'function') {
							promise.then(resolver(i), reject);
						} else {
							results[i] = promise;
						}
					}

					if (!remaining) {
						resolve(results);
					}
				});
			};

			Promise.race = function (promises) {
				if (!Array.isArray(promises)) {
					throw new TypeError('You must pass an array to Promise.race().');
				}

				return new Promise(function (resolve, reject) {
					for (var i = 0, promise; i < promises.length; i++) {
						promise = promises[i];

						if (promise && typeof promise.then === 'function') {
							promise.then(resolve, reject);
						} else {
							resolve(promise);
						}
					}
				});
			};

			Promise.resolve = function (value) {
				if (value && typeof value === 'object' && value.constructor === Promise) {
					return value;
				}

				return new Promise(function (resolve) {
					resolve(value);
				});
			};

			Promise.reject = function (reason) {
				return new Promise(function (resolve, reject) {
					reject(reason);
				});
			};

			module.exports = Promise;
		}
	},
	"qunit-harness": {
		"src": {
			"templates": {
				"globals.mustache.js": function (exports, module, require) {
					var Promise = require('pinkie');
					
					var WAIT_TIMEOUT             = 3000;
					var WAIT_FOR_IFRAME_TIMEOUT  = 10000;
					var CHECK_PREDICATE_INTERVAL = 50;
					
					window.QUnitGlobals = {
					    _taskId:   '{{{taskId}}}',
					    _path:     '{{{path}}}',
					    _fullPath: '{{{testFullPath}}}',
					
					    hostname:            '{{{hostname}}}',
					    crossDomainHostname: '{{{crossDomainHostname}}}',
					
					    getResourceUrl: function (filePath, resourceName) {
					        return [
					            '/test-resource',
					            resourceName ? '/' + resourceName : '',
					            '?filePath=',
					            encodeURIComponent(filePath),
					            '&base=',
					            window.QUnitGlobals._fullPath
					        ].join('');
					    },
					
					    wait: function (condition, ms) {
					        return new Promise(function (resolve) {
					            var timeoutId  = null;
					            var intervalId = null;
					
					            timeoutId = window.setTimeout(function () {
					                window.clearInterval(intervalId);
					                window.clearTimeout(timeoutId);
					                ok(false, 'Timeout error');
					                start();
					            }, ms === void 0 ? WAIT_TIMEOUT : ms);
					
					            intervalId = window.setInterval(function () {
					                if (condition()) {
					                    window.clearInterval(intervalId);
					                    window.clearTimeout(timeoutId);
					                    resolve();
					                }
					            }, CHECK_PREDICATE_INTERVAL);
					        });
					    },
					
					    waitForIframe: function (iframe, timeout) {
					        return new Promise(function (resolve, reject) {
					            var timeoutId      = null;
					            var isIframeLoaded = false;
					
					            function loadEventHandler () {
					                window.clearTimeout(timeoutId);
					                iframe.removeEventListener('load', loadEventHandler);
					                resolve();
					            }
					
					            if (!iframe || !iframe.tagName || iframe.tagName.toLowerCase() !== 'iframe')
					                throw 'Incorrect waitForIframe argument';
					
					            timeoutId = window.setTimeout(function () {
					                window.clearTimeout(timeoutId);
					                iframe.removeEventListener('load', loadEventHandler);
					                ok(false, 'Timeout error');
					                start();
					            }, timeout === void 0 ? WAIT_FOR_IFRAME_TIMEOUT : timeout);
					
					            try {
					                isIframeLoaded = iframe.contentWindow && iframe.contentWindow.document &&
					                                 iframe.contentWindow.document.readyState === 'complete';
					            }
					            catch (e) {
					                //NOTE: if cross-domain iframe raises an error we take it as loaded
					                isIframeLoaded = true
					            }
					
					            if (isIframeLoaded) {
					                window.clearTimeout(timeoutId);
					                resolve();
					                return;
					            }
					
					            iframe.addEventListener('load', loadEventHandler);
					        });
					    },
					
					    WAIT_FOR_IFRAME_TIMEOUT: WAIT_FOR_IFRAME_TIMEOUT
					};
				}
			}
		}
	}
})("qunit-harness/src/templates/globals.mustache");
